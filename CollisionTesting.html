// World's Hardest Game, 2019

<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>World's Hardest Game</title>
        <link rel="stylesheet" type="text/css" href="style.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
        <script>
// The user-controlled entity that performs actions in the game
//let player = new Player();

// Global variables for the HTML5 canvas
var canvas;
var context;
var obstacles;
var oldTimeStamp;

// Details for the screen and its size
var xMin;
var xMax;
var yMin;
var yMax;

// Information for setInterval() and clearInterval()
var intervalId = null;
const updateInterval = 10; // interval in milliseconds

//Setting up the player
var player;

//Movement booleans for smooth moves
var up = false;
var down = false;
var right = false;
var left = false;

document.addEventListener('keydown', (e) => {
    e.preventDefault();
    if (e.code === "ArrowUp")        up = true;
    else if (e.code === "ArrowDown") down = true;
    else if(e.code === "ArrowRight") right = true;
    else if(e.code === "ArrowLeft")  left = true;
});

document.addEventListener('keyup', (e) => {
    e.preventDefault();
    if (e.code === "ArrowUp")        up = false;
    else if (e.code === "ArrowDown") down = false;
    else if(e.code === "ArrowRight") right = false;
    else if(e.code === "ArrowLeft")  left = false;
});

function setUpGame() {
    // Stops updating the game state before restarting
    if (intervalId != null) {
        clearInterval(intervalId);
    }

    var aleksFace = "https://scontent-sea1-1.cdninstagram.com/vp/e92b43bf1d1c01d0a298e3937733c06c/5DD9D0C6/t51.2885-19/s150x150/52486763_624841137975557_4315053367689740288_n.jpg?_nc_ht=scontent-sea1-1.cdninstagram.com";
    var andrewFace = "https://greenecounty.alumni.osu.edu/wp-content/uploads/sites/25/2018/06/Andrew-Haberlandt.jpg";

    obstacles = [
        //image URL, image widht, image height, speed X, speed Y, start X, start Y, end X, end Y
        new Obstacle(aleksFace, 100, 100, 0, .25, 10, 10, 1100, 500, 200, 200),
        new Obstacle(aleksFace, 100, 100, .2, .25, 10, 10, 1100, 500, 200, 200)
    ];

    player = new Player(andrewFace, 100, 100, 3, 10, 10);

    xMin = 0;
    xMax = 1200; 
    yMin = 0;
    yMax = 500;
    
    canvas = document.getElementById("board");
    canvas.width = xMax;
    canvas.height = yMax;
    context = canvas.getContext("2d");

    intervalId = setInterval(updateGameState, updateInterval);
}

// 2D point within bounds of screen
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;

        this.checkPoint();
    }

    checkPoint() {
        if (this.x < xMin || this.x > xMax) {
            alert("x-coordinate " + this.x + " is out of range, xMin = " + xMin + " and xMax = " + xMax);
        }
        if (this.y < yMin || this.y > yMax) {
            alert("y-coordinate " + this.y + " is out of range, yMin = " + yMin + " and yMax = " + yMax);
        }
    }
    
    subtractX(subtractFromX) {
        this.x -= subtractFromX;
        this.checkPoint();
    }

    subtractY(subtractFromY) {
        this.y -= subtractFromY;
        this.checkPoint();
    }

    addX(addToX) {
        this.x += addToX;
        this.checkPoint();
    }

    addY(addToY) {
        this.y += addToY;
        this.checkPoint();
    }
}

// Game obstacle
class Obstacle {
    constructor(imageSrc, imageWidth, imageHeight, speedX, speedY, startPointX, startPointY, endPointX, endPointY, currentPointX, currentPointY) {
        this.image = new Image(imageWidth, imageHeight);
        this.image.src = imageSrc;
        this.speedX = speedX;
        this.speedY = speedY;
        this.startPoint = new Point(startPointX, startPointY);
        this.currentPoint = new Point(currentPointX, currentPointY);
        this.endPoint = new Point(endPointX - (this.image.width), endPointY - (this.image.height));
    }
}

class Player {
    constructor(imageSrc, imageWidth, imageHeight, speed, pointX, pointY) {
        this.image = new Image(imageWidth, imageHeight);
        this.image.src = imageSrc;
        this.speed = speed;
        this.currentPoint = new Point(pointX, pointY);
        this.crashCheck = function()
        {
            return isPlayerTouchingObstacle(this);   
        }
    }

    moveRight() {
        if(this.currentPoint.x  + player.speed <= xMax - this.image.width)
        {
            this.currentPoint.addX(player.speed);
        }
    }

    moveLeft() {
        if(this.currentPoint.x - player.speed >= xMin)
        {
            this.currentPoint.subtractX(player.speed);
        }
    }

    moveUp() {
        if(this.currentPoint.y - player.speed >= yMin)
        {
            this.currentPoint.subtractY(player.speed);
        }
    }

    moveDown() {
        if(this.currentPoint.y + player.speed <= yMax - this.image.height)
        {
            this.currentPoint.addY(player.speed);
        }
    }
}

function updateGameState() {
    moveAndDrawObstacles();
    drawCourseEdge();
    moveAndDrawPlayer();
    if (player.crashCheck())
    {
        myGameArea.context.fillStyle = "#000000";
        myGameArea.context.font = "30px Arial";
        myGameArea.context.fillText("Game Over", 30, 50);
        return;
    }
}

function moveAndDrawPlayer()
{
    if(up)
    {
        player.moveUp();
    }
    if(down)
    {
        player.moveDown();
        console.log("Hello collision!!");
    }
    if(left)
    {
        player.moveLeft();
    }
    if(right)
    {
        player.moveRight();
    }
    drawImage(player.image, player.currentPoint);
}

function moveAndDrawObstacles() {
    clearCanvas();
    for(var i = 0; i < obstacles.length; i++)
    {
        //calculate future position of the obstacle
        obstacles[i].currentPoint.addX(obstacles[i].speedX * updateInterval);
        obstacles[i].currentPoint.addY(obstacles[i].speedY * updateInterval);
        
        if(obstacles[i].currentPoint.x < obstacles[i].startPoint.x || obstacles[i].currentPoint.x > obstacles[i].endPoint.x || obstacles[i].currentPoint.y < obstacles[i].startPoint.y || obstacles[i].currentPoint.y > obstacles[i].endPoint.y){
            obstacles[i].speedX *= -1;
            obstacles[i].speedY *= -1;
        }

        //draw the obstacle
        drawImage(obstacles[i].image, obstacles[i].currentPoint);
    }
}

function clearCanvas() {
    context.clearRect(0, 0, canvas.width, canvas.height);
}

// Draws an image object on the canvas at the given point
function drawImage(image, point) {
    // Draw the image at the point
    context.drawImage(image, point.x, point.y, image.width, image.height);
}

function drawCourseEdge() {
    var board = document.getElementById("board");
    var context = board.getContext("2d");
    context.fillStyle = "#000000";
    context.fillRect(xMax/3, yMax/3, 100, 200);
}
            
// Used to determine if the the player shape has touched an obstacle
function isPlayerTouchingObstacle(player)
{
    let defaultPlayerCoordinates = 
    {
        topLeft: new Point(player.x - (player.width / 2), player.y - (player.height / 2)), // Top-Left Point
        topRight: new Point(player.x + (player.width / 2), player.y - (player.height / 2)), // Top-Right Point
        bottomLeft: new Point(player.x - (player.width / 2), player.y + (player.height / 2)), // Bottom-Left Point
        bottomRight: new Point(player.x + (player.width / 2), player.y + (player.height / 2))  // Bottom-Right Point
    }

    let isPlayerTouchingObstacle = false;
    
    //***We will likely need a different collision detection system for different obstacle types (squares, circles, etc.)
    for (var i = 0; i < obstacles.length; i++)
    {
           let obstacleMinX = obstacles[i][9];
           let obstacleMaxX = obstacles[i][9] + obstacles[i][1];
           let obstacleMinY = obstacles[i][10];
           let obstacleMaxY = obstacles[i][10] + obstacles[i][2];
           if (defaultPlayerCoordinates.topLeft.x >= obstacleMinX && defaultPlayerCoordinates.topLeft.x <= obstacleMaxX && defaultPlayerCoordinates.topLeft.y >= obstacleMinY && defaultPlayerCoordinates.topLeft.y <= obstacleMaxY ||
                defaultPlayerCoordinates.topRight.x >= obstacleMinX && defaultPlayerCoordinates.topRight.x <= obstacleMaxX && defaultPlayerCoordinates.topRight.y >= obstacleMinY && defaultPlayerCoordinates.topRight.y <= obstacleMaxY ||
                defaultPlayerCoordinates.bottomLeft.x >= obstacleMinX && defaultPlayerCoordinates.bottomLeft.x <= obstacleMaxX && defaultPlayerCoordinates.bottomLeft.y >= obstacleMinY && defaultPlayerCoordinates.bottomLeft.y <= obstacleMaxY ||
                defaultPlayerCoordinates.bottomRight.x >= obstacleMinX && defaultPlayerCoordinates.bottomRight.x <= obstacleMaxX && defaultPlayerCoordinates.bottomRight.y >= obstacleMinY && defaultPlayerCoordinates.bottomRight.y <= obstacleMaxY)
            {
                 isPlayerTouchingObstacle = true;
                 console.log("Hello collision!");
            }
    }
    return isPlayerTouchingObstacle;        
}

//!!! Under Construction !!!
// Used to check if player is within bounds
// This checks if any point is off a rectangle, not that any point is inside a rectangle like isCarTouchingRectangle
// Because our course is only rectangles and not defined by the walls, this needs to be much more complex :P 
function isPlayerOffPath(player)
{
    // Each corner is defined as a "Point" - Has x and y properties / data fields 
    let defaultPlayerCoordinates = 
    {
        topLeft: new Point(player.x - (player.width / 2), player.y - (player.height / 2)), // Top-Left Point
        topRight: new Point(player.x + (player.width / 2), player.y - (player.height / 2)), // Top-Right Point
        bottomLeft: new Point(player.x - (player.width / 2), player.y + (player.height / 2)), // Bottom-Left Point
        bottomRight: new Point(player.x + (player.width / 2), player.y + (player.height / 2))  // Bottom-Right Point
    }
    let areAllPointsInsideARectangle = true;
    // If any of the points are "not in a rectangle" then the player is "off path" and this entire method returns false 
    if (!isPointInsideARectangle(defaultPlayerCoordinates.topLeft)) { areAllPointsInsideARectangle = false; }    
    else if (!isPointInsideARectangle(defaultPlayerCoordinates.topRight)) { areAllPointsInsideARectangle = false; }
    else if (!isPointInsideARectangle(defaultPlayerCoordinates.bottomLeft)) { areAllPointsInsideARectangle = false; }
    else if (!isPointInsideARectangle(defaultPlayerCoordinates.bottomRight)) { areAllPointsInsideARectangle = false; }
    // If you're wondering why this is negated, the boolean value here is the opposite of what we're trying to return as part of the method
    // If they're "all inside a rectangle", it's on the path. Therefore, this function should return that it's "not off the path", or, on the path.  
    return !areAllPointsInsideARectangle;
}

// Does exactly what it says - Functions should be as self-documenting as possible w/o needing comments 
function isPointInsideARectangle(point)
{
    let isPointInsideARectangle = false;
    // Iterates through each rectangle on the course 
    for (let i = 0; i < obstacles.length; i++)
    {
        // Determining the bounds for the rectangle 
        let obstacleMinX = obstacles[i][0];
        let obstacleMaxX = obstacles[i][0] + obstalces[i][2];
        let obstacleMinY = obstacles[i][1];
        let obstacleMaxY = obstacles[i][1] + obstalces[i][3];
        if (point.x >= obstacleMinX && point.x <= obstacleMaxX && point.y >= obstacleMinY && point.y <= obstacleMaxY)
        {
            isPointInsideARectangle = true;
            break;
        }
    }
    return isPointInsideARectangle;
}

</script>
</head>
    <body style="background-color: #d3d3d3;">
        <nav>
            <div class="nav-wrapper">
                <a href="#" class="brand-logo center">World's Hardest Game</a>
            </div>
        </nav>

        <div class="container-fluid" style="background-color: #cccccc; padding: 10px 10px;">
            <div class="center">
                <canvas id="board" style="background-color: #ffffff;"></canvas>
            </div>

            <div class="center">
                <button onclick="setUpGame()" class="btn-large waves-effect waves-light start-button center">Start Game</button>
                <p>Insert game instructions here</p>
            </div>
        </div>
    </body>
</html>
