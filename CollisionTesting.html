// World's Hardest Game, 2019
<!DOCTYPE html>
<html>
    <head>

        <!-- What appears in the title bar -->
        <title>OSU Racing Game</title>

    </head>

    <body>
    
<script>
// The user-controlled entity that performs actions in the game
//let player = new Player();
// Global variables for the Canvas
var context;
var canvas;
var obstacles;
var oldTimeStamp;

// Details for the screen and its size
var xMin;
var xMax;
var yMin;
var yMax;
    
var animationFrameId = null;
    
function setUpGame() {
    // Since the gameLoop will run forever, we need to stop it before restarting it here
    if (animationFrameId != null) {
        window.cancelAnimationFrame(animationFrameId);
    }
    obstacleData = [
        // Format for each entry is as follows: 
        // image URL, speedX, speedY, topLimitX, bottomLimitX, topLimitY, bottomLimitY, currentX, currentY
        [aleksFace,   0,      0.2,    0,         1200,         10,        500,          150,      10],
        [aleksFace,   0,      0.2,    0,         1200,         10,        500,          700,      10]
    ];
    obstacles = [];
    oldTimeStamp = 0.0;
    xMin = 0;
    xMax = 1200; 
    yMin = 0;
    yMax = 500;
    
    canvas = document.getElementById("board");
    canvas.width = xMax;
    canvas.height = yMax;
    context = canvas.getContext("2d");

    // Constructs obstacles from array of obstacle data
    parseObstacles(obstacleData);

    // Debugging statements
    console.log("Parsed obstacles after setUpGame(): ");
    console.log(obstacles);

    // window.requestAnimationFrame runs and then runs the function you pass to it
    // Since gameLoop calls window.requestAnimationFrame(gameLoop) it will run forever
    animationFrameId = window.requestAnimationFrame(gameLoop);
}
// Creates a 2D Point within the bounds of the screen
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;

        if (x < xMin || x > xMax) {
            alert("x-coordinate " + x + " is out of range, xMin = " + xMin + " and xMax = " + xMax);
        }
        if (y < yMin || y > yMax) {
            alert("y-coordinate " + y + " is out of range, yMin = " + yMin + " and yMax = " + yMax);
        }
    }
}

// Constructor for an Obstacle
class Obstacle {
    constructor(image, speed, startPoint, endPoint) {
        //the this.image is an image object
        this.image = image;
        this.speed = speed;
        // All of these are Point's
        this.startPoint = startPoint;
        this.currentPoint = new Point(0, 0);
        this.endPoint = endPoint;
    }
}

function gameLoop(timeStamp)
{
    var timePassed = timeStamp - oldTimeStamp;
    oldTimeStamp = timeStamp;

    updateObstaclePositions(timePassed);
    animationFrameId = window.requestAnimationFrame(gameLoop);
}

function updateObstaclePositions(timePassed)
{
    context.clearRect(0, 0, canvas.width, canvas.height);
    for(var i = 0; i < obstacles.length; i++)
    {
        //calculate future position of the obstacle
        obstacles[i].currentPoint.x += obstacles[i].speed * timePassed;
        obstacles[i].currentPoint.y += obstacles[i].speed * timePassed;
        if(obstacles[i].currentPoint.x < obstacles[i].startPoint.x || obstacles[i].currentPoint.x > obstacles[i].endPoint.x)
        {
            obstacles[i].speedX *= -1;
        }

        if(obstacles[i].currentPoint.y < obstacles[i].startPoint.y || obstacles[i].currentPoint.y > obstacles[i].endPoint.y)
        {
            obstacles[i].speedY *= -1;
        }
        //draw the obstacle
        drawImage(obstacles[i].image, obstacles[i].currentPoint);
    }
}

function drawImage(image, point)
{
    //clear the canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    //draw the image at the point
    context.drawImage(image, point.x, point.y);
}

// Used to determine if the the player shape has touched an obstacle
function isPlayerTouchingObstacle(player, obstacle)
{
    let defaultPlayerCoordinates = 
    {
        topLeft: new Point(player.x - (player.width / 2), player.y - (player.height / 2)), // Top-Left Point
        topRight: new Point(player.x + (player.width / 2), player.y - (player.height / 2)), // Top-Right Point
        bottomLeft: new Point(player.x - (player.width / 2), player.y + (player.height / 2)), // Bottom-Left Point
        bottomRight: new Point(player.x + (player.width / 2), player.y + (player.height / 2))  // Bottom-Right Point
    }

    //***We will likely need a different collision detection system for different obstacle types (squares, circles, etc.)
    let obstacleMinX = obstacle[0];
    let obstacleMaxX = obstacle[0] + obstacle[2];
    let obstacleMinY = obstacle[1];
    let obstacleMaxY = obstacle[1] + obstacle[3];

    let isPlayerTouchingObstacle = false;

    if (defaultPlayerCoordinates.topLeft.x >= obstacleMinX && defaultPlayerCoordinates.topLeft.x <= obstacleMaxX && defaultPlayerCoordinates.topLeft.y >= obstacleMinY && defaultPlayerCoordinates.topLeft.y <= obstacleMaxY ||
        defaultPlayerCoordinates.topRight.x >= obstacleMinX && defaultPlayerCoordinates.topRight.x <= obstacleMaxX && defaultPlayerCoordinates.topRight.y >= obstacleMinY && defaultPlayerCoordinates.topRight.y <= obstacleMaxY ||
        defaultPlayerCoordinates.bottomLeft.x >= obstacleMinX && defaultPlayerCoordinates.bottomLeft.x <= obstacleMaxX && defaultPlayerCoordinates.bottomLeft.y >= obstacleMinY && defaultPlayerCoordinates.bottomLeft.y <= obstacleMaxY ||
        defaultPlayerCoordinates.bottomRight.x >= obstacleMinX && defaultPlayerCoordinates.bottomRight.x <= obstacleMaxX && defaultPlayerCoordinates.bottomRight.y >= obstacleMinY && defaultPlayerCoordinates.bottomRight.y <= obstacleMaxY)
    {
        isPlayerTouchingObstacle = true;
    }

    return isPlayerTouchingObstacle;        
}

//!!! Under Construction !!!
// Used to check if player is within bounds
// This checks if any point is off a rectangle, not that any point is inside a rectangle like isCarTouchingRectangle
// Because our course is only rectangles and not defined by the walls, this needs to be much more complex :P 
function isPlayerOffPath(player)
{
    // Each corner is defined as a "Point" - Has x and y properties / data fields 
    let defaultPlayerCoordinates = 
    {
        topLeft: new Point(player.x - (player.width / 2), player.y - (player.height / 2)), // Top-Left Point
        topRight: new Point(player.x + (player.width / 2), player.y - (player.height / 2)), // Top-Right Point
        bottomLeft: new Point(player.x - (player.width / 2), player.y + (player.height / 2)), // Bottom-Left Point
        bottomRight: new Point(player.x + (player.width / 2), player.y + (player.height / 2))  // Bottom-Right Point
    }
    let areAllPointsInsideARectangle = true;
    // If any of the points are "not in a rectangle" then the player is "off path" and this entire method returns false 
    if (!isPointInsideARectangle(defaultPlayerCoordinates.topLeft)) { areAllPointsInsideARectangle = false; }    
    else if (!isPointInsideARectangle(defaultPlayerCoordinates.topRight)) { areAllPointsInsideARectangle = false; }
    else if (!isPointInsideARectangle(defaultPlayerCoordinates.bottomLeft)) { areAllPointsInsideARectangle = false; }
    else if (!isPointInsideARectangle(defaultPlayerCoordinates.bottomRight)) { areAllPointsInsideARectangle = false; }
    // If you're wondering why this is negated, the boolean value here is the opposite of what we're trying to return as part of the method
    // If they're "all inside a rectangle", it's on the path. Therefore, this function should return that it's "not off the path", or, on the path.  
    return !areAllPointsInsideARectangle;
}

// Does exactly what it says - Functions should be as self-documenting as possible w/o needing comments 
function isPointInsideARectangle(point)
{
    let isPointInsideARectangle = false;
    // Iterates through each rectangle on the course 
    for (let i = 0; i < obstacles.length; i++)
    {
        // Determining the bounds for the rectangle 
        let obstacleMinX = obstacles[i][0];
        let obstacleMaxX = obstacles[i][0] + obstalces[i][2];
        let obstacleMinY = obstacles[i][1];
        let obstacleMaxY = obstacles[i][1] + obstalces[i][3];
        if (point.x >= obstacleMinX && point.x <= obstacleMaxX && point.y >= obstacleMinY && point.y <= obstacleMaxY)
        {
            isPointInsideARectangle = true;
            break;
        }
    }
    return isPointInsideARectangle;
}

</script>

    </body>
</html>
